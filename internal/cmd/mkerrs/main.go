package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"
)

var resources = []string{
	"OK",
	"USAGE",
	"DATAERR",
	"NOINPUT",
	"NOUSER",
	"NOHOST",
	"UNAVAILABLE",
	"SOFTWARE",
	"OSERR",
	"OSFILE",
	"CANTCREAT",
	"IOERR",
	"TEMPFAIL",
	"PROTOCOL",
	"NOPERM",
	"CONFIG",
}

var descriptions = map[string]string{
	"OK":          "the successful exit is always indicated by a status of 0.",
	"USAGE":       "the command was used incorrectly, e.g., with the\nwrong number of arguments, a bad flag, a bad syntax\nin a parameter, or whatever",
	"DATAERR":     "the input data was incorrect in some way. This\nshould only be used for user's data and not system\nfiles",
	"NOINPUT":     "an input file (not a system file) did not exist or\nwas not readable. This could also include errors\nlike `No message` to a mailer (if it cared to\ncatch it).",
	"NOUSER":      "the user specified did not exist. This might be\nused for mail addresses or remote logins.",
	"NOHOST":      "the host specified did not exist. This is used in\nmail addresses or network requests.",
	"UNAVAILABLE": "a service is unavailable. This can occur if a support\nprogram or file does not exist. This can also\nbe used as a catchall message when something you\nwanted to do doesn't work, but you don't know why.",
	"SOFTWARE":    "an internal software error has been detected. This\nshould be limited to non-operating system related\nerrors as possible.",
	"OSERR":       "an operating system error has been detected. This\nis intended to be used for such things as `cannot\nfork`, `cannot create pipe`, or the like. It\nincludes things like getuid returning a user that\ndoes not exist in the passwd file.",
	"OSFILE":      "some system file (e.g., /etc/passwd, /var/run/utmp,\netc.) does not exist, cannot be opened, or has some\nsort of error (e.g., syntax error).",
	"CANTCREAT":   "a (user specified) output file cannot be created.",
	"IOERR":       "an error occurred while doing I/O on some file.",
	"TEMPFAIL":    "temporary failure, indicating something that is not\nreally an error. In sendmail, this means that a\nmailer (e.g.) could not create a connection, and\nthe request should be reattempted later.",
	"PROTOCOL":    "the remote system returned something that was `not\npossible` during a protocol exchange.",
	"NOPERM":      "you did not have sufficient permission to perform\nthe operation.  This is not intended for file sys­tem\nproblems, which should use NOINPUT or\nCANTCREAT, but rather for higher level permis­sions.",
	"CONFIG":      "Something was found in an unconfigured or\nmiscon­figured state.",
}

func main() {
	var buf bytes.Buffer
	buf.WriteString("package exit\n\n")
	buf.WriteString("// Auto generated by `mkerrs` in internal/cmd/mkerrs/main.go\n")
	buf.WriteString("// Do not edit this.\n")
	buf.WriteString("import \"errors\"\n\n")

	buf.WriteString(`
type base struct {
	err error
	code int
}
`)

	for _, resource := range resources {
		name := strings.ToLower(resource)
		top := name[0]
		description := descriptions[resource]
		comments := strings.Split(resource+" means "+description, "\n")
		for _, comment := range comments {
			fmt.Fprintf(&buf, "// %s\n", comment)
		}
		fmt.Fprintf(&buf, "type %s struct { base }\n", name)
		fmt.Fprintf(&buf, `
func (%c %s) ExitCode() int { return %c.code }
func (%c %s) Error() string { return %c.err.Error() }
`, top, name, top, top, name, top)
		fmt.Fprintf(&buf, "func Make%s(str string) %s { return %s{base{err: errors.New(str), code: %s}} }\n",
			resource, name, name, resource)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("%s", err.Error())
	}

	fh, err := os.Create("errors.go")
	if err != nil {
		log.Fatalf("%s", err.Error())
	}
	defer fh.Close()

	fh.Write(formatted)
	fmt.Println("Completed")
}
