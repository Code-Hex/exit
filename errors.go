package exit

// Auto generated by `mkerrs` in internal/cmd/mkerrs/main.go
// Do not edit this.
import "errors"

type base struct {
	err  error
	code int
}

// OK means the successful exit is always indicated by a status of 0.
type ok struct{ base }

func (o ok) ExitCode() int { return o.code }
func (o ok) Error() string { return o.err.Error() }
func MakeOK(str string) ok { return ok{base{err: errors.New(str), code: OK}} }

// USAGE means the command was used incorrectly, e.g., with the
// wrong number of arguments, a bad flag, a bad syntax
// in a parameter, or whatever
type usage struct{ base }

func (u usage) ExitCode() int    { return u.code }
func (u usage) Error() string    { return u.err.Error() }
func MakeUSAGE(str string) usage { return usage{base{err: errors.New(str), code: USAGE}} }

// DATAERR means the input data was incorrect in some way. This
// should only be used for user's data and not system
// files
type dataerr struct{ base }

func (d dataerr) ExitCode() int      { return d.code }
func (d dataerr) Error() string      { return d.err.Error() }
func MakeDATAERR(str string) dataerr { return dataerr{base{err: errors.New(str), code: DATAERR}} }

// NOINPUT means an input file (not a system file) did not exist or
// was not readable. This could also include errors
// like `No message` to a mailer (if it cared to
// catch it).
type noinput struct{ base }

func (n noinput) ExitCode() int      { return n.code }
func (n noinput) Error() string      { return n.err.Error() }
func MakeNOINPUT(str string) noinput { return noinput{base{err: errors.New(str), code: NOINPUT}} }

// NOUSER means the user specified did not exist. This might be
// used for mail addresses or remote logins.
type nouser struct{ base }

func (n nouser) ExitCode() int     { return n.code }
func (n nouser) Error() string     { return n.err.Error() }
func MakeNOUSER(str string) nouser { return nouser{base{err: errors.New(str), code: NOUSER}} }

// NOHOST means the host specified did not exist. This is used in
// mail addresses or network requests.
type nohost struct{ base }

func (n nohost) ExitCode() int     { return n.code }
func (n nohost) Error() string     { return n.err.Error() }
func MakeNOHOST(str string) nohost { return nohost{base{err: errors.New(str), code: NOHOST}} }

// UNAVAILABLE means a service is unavailable. This can occur if a support
// program or file does not exist. This can also
// be used as a catchall message when something you
// wanted to do doesn't work, but you don't know why.
type unavailable struct{ base }

func (u unavailable) ExitCode() int { return u.code }
func (u unavailable) Error() string { return u.err.Error() }
func MakeUNAVAILABLE(str string) unavailable {
	return unavailable{base{err: errors.New(str), code: UNAVAILABLE}}
}

// SOFTWARE means an internal software error has been detected. This
// should be limited to non-operating system related
// errors as possible.
type software struct{ base }

func (s software) ExitCode() int       { return s.code }
func (s software) Error() string       { return s.err.Error() }
func MakeSOFTWARE(str string) software { return software{base{err: errors.New(str), code: SOFTWARE}} }

// OSERR means an operating system error has been detected. This
// is intended to be used for such things as `cannot
// fork`, `cannot create pipe`, or the like. It
// includes things like getuid returning a user that
// does not exist in the passwd file.
type oserr struct{ base }

func (o oserr) ExitCode() int    { return o.code }
func (o oserr) Error() string    { return o.err.Error() }
func MakeOSERR(str string) oserr { return oserr{base{err: errors.New(str), code: OSERR}} }

// OSFILE means some system file (e.g., /etc/passwd, /var/run/utmp,
// etc.) does not exist, cannot be opened, or has some
// sort of error (e.g., syntax error).
type osfile struct{ base }

func (o osfile) ExitCode() int     { return o.code }
func (o osfile) Error() string     { return o.err.Error() }
func MakeOSFILE(str string) osfile { return osfile{base{err: errors.New(str), code: OSFILE}} }

// CANTCREAT means a (user specified) output file cannot be created.
type cantcreat struct{ base }

func (c cantcreat) ExitCode() int { return c.code }
func (c cantcreat) Error() string { return c.err.Error() }
func MakeCANTCREAT(str string) cantcreat {
	return cantcreat{base{err: errors.New(str), code: CANTCREAT}}
}

// IOERR means an error occurred while doing I/O on some file.
type ioerr struct{ base }

func (i ioerr) ExitCode() int    { return i.code }
func (i ioerr) Error() string    { return i.err.Error() }
func MakeIOERR(str string) ioerr { return ioerr{base{err: errors.New(str), code: IOERR}} }

// TEMPFAIL means temporary failure, indicating something that is not
// really an error. In sendmail, this means that a
// mailer (e.g.) could not create a connection, and
// the request should be reattempted later.
type tempfail struct{ base }

func (t tempfail) ExitCode() int       { return t.code }
func (t tempfail) Error() string       { return t.err.Error() }
func MakeTEMPFAIL(str string) tempfail { return tempfail{base{err: errors.New(str), code: TEMPFAIL}} }

// PROTOCOL means the remote system returned something that was `not
// possible` during a protocol exchange.
type protocol struct{ base }

func (p protocol) ExitCode() int       { return p.code }
func (p protocol) Error() string       { return p.err.Error() }
func MakePROTOCOL(str string) protocol { return protocol{base{err: errors.New(str), code: PROTOCOL}} }

// NOPERM means you did not have sufficient permission to perform
// the operation.  This is not intended for file sys­tem
// problems, which should use NOINPUT or
// CANTCREAT, but rather for higher level permis­sions.
type noperm struct{ base }

func (n noperm) ExitCode() int     { return n.code }
func (n noperm) Error() string     { return n.err.Error() }
func MakeNOPERM(str string) noperm { return noperm{base{err: errors.New(str), code: NOPERM}} }

// CONFIG means Something was found in an unconfigured or
// miscon­figured state.
type config struct{ base }

func (c config) ExitCode() int     { return c.code }
func (c config) Error() string     { return c.err.Error() }
func MakeCONFIG(str string) config { return config{base{err: errors.New(str), code: CONFIG}} }
